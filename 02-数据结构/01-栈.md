## 栈

​	栈是一种“先进后出”的线性数据结构。栈只有一端能够进出元素。能进出元素的一端叫栈顶，不能进出元素的一端叫栈底。当我们添加或者删除元素的时候，只能从栈顶操作。

![image-20201205151854875](https://i.loli.net/2020/12/05/TIgM1ozwketxyUA.png)

上图就是一个栈，栈里面有三个元素。其中 3 号元素是栈顶，1 号元素栈底。只有当前元素是栈顶的时候才能出栈。所以上图只有 3 号元素可以出栈。如果 3 号元素出栈，那么栈顶就会变成 2 号元素。

我们也可以用数组来模拟栈：

- 定义数组和栈顶元素的位置，`1` 为栈底 : `int stack[SIZE], top = 0;` 
- 入栈 `x`  :  `stack[++top] = x`
- 访问栈顶元素：  `stack[top]`
- 出栈： `top--`

一开始栈里面没有元素，所以 `top` 的值是 `0`， `top` 可以代表栈顶所在的位置，也可以代表栈里面有多少个元素。

访问栈顶元素的时候，需要提前判断一下栈里面有没有元素，如果有才能返回栈顶元素。

#### 例题

​	实现一个栈，支持 Push（入栈）、Pop（出栈）和 GetMax （查询栈内元素的最大值）三个操作，要求时间复杂度均为 O(1).

**思路：**

​	要求时间复杂度为O(1), 所以每 Push 一个元素的时候就要立刻知道最大值，所以我们可以定义一个变量 y 来表示当前栈里面元素的最大值，如果有元素进来，就可以和 y 比较一下，取最大就可以了。

​	![image-20201205154625263](https://i.loli.net/2020/12/05/7Jq3yEevkdlOrUV.png)

​	具体来说，就是维护两个栈，栈 A 存储原本的数据，栈 B 存储栈 A 中以栈底开头的每段数据的最大值。如上图所示：

​	当执行 Push(y) 的时候，在 A 中插入 y，在 B 中插入 max(y, B的栈顶数据)。在执行Pop操作时，在 A、B 两个栈中分别出栈。在执行 GetMax 操作时，取出 B栈的栈顶元素就可以了。

```c++
class Stack {
public:
    Stack() {
    	top = 0;  // 一开始栈为空， 所以 top = 0.
    }
    void Push(int value) {  
    	A[++top] = value; // 首先把元素放到 A 栈里面。
    	B[top] = value;   // 直接放到 B 栈里面。 
    	if (top - 1 > 0) B[top] = max(B[top], B[top - 1]); // 如果之前 B 栈有元素， 那么比较一下，取个最大值。
    }
    
    void Pop() {
    	if (top > 0) --top;  // 元素个数减一。
    }
    int GetMax(){
    	return B[top]; // 取出最大的值，去之前需要判断一下栈里面有没有元素，这里我没有写。
    }
    int A[SIZE];  // A 栈
    int B[SIZE];  // B 栈
    int top;      // 栈顶元素的位置， 即栈内元素的个数。 
};
```



### 单调栈

单调栈内的元素是递增或者递减的。

单调栈的作用：

- 求左面第一个大于或者小于当前元素的位置
- 求右面第一个大于或者小于当前元素的位置

#### 例题：

​	一个数组 arr， 有 n 个数字， 对于每个位置的数字，求左边第一个小于当前数字的位置。

**示例：**

```c++
输入： arr = [2, 4, 6, 5, 3, 1, 8]
输出： [-1, 0, 1, 1, 0, -1, 5]
```

如果是暴力， 那就对每一个位置 i， 然后向前找，遇到大于等于当前数的接着找，直到找到一个小于的位置  j。

```c++
int n = arr.size(); // 数组大小
for (int i = 0; i < n; ++i){  // 枚举每一个值
    int pos = -1; // 初始化位置， 如果找不到就是 -1
    for (int j = i-1; j >= 0; --j){  // 枚举小于 i 的所有位置，一旦出现小于当前值的位置，就记录下来然后退出。
        if (arr[j] < arr[i]) {
            pos = j;
            break;
        }
    }
    ans.push_back(pos); // 记录答案
}
```

这样的时间复杂度是 $O(n^2)$ 的。一点都不优雅，下面我们来了解一下更优雅的单调栈做法：

​	对于 `i`， `i-1` 这两个位置。`i` 可以复用 `i-1` 的情况。如果 `arr[i] > arr[i-1]`， 那么 `i` 这个位置的答案就是 `i-1`, 否则 `i` 就要向前找，这个时候 `i` 就可以复用 `i-1` 的情况了， 因为 `i-1` 跳过的值就是 `>= arr[i-1]` 的， `arr[i-1] >= a[i]`，所以 跳过的值必然也是 `>= arr[i]` 的， 所以这些值也就可以直接跳过。

​	知道了上面的流程，就可以来了解怎么使用单调栈了。 

​	栈里面维护的是每个值的位置。当加入一个新值的时候，用新值不断的和栈顶代表的元素进行比较，如果新值大于栈顶，那么栈顶就是我们要找的位置， 否则就是新值小于等于栈顶所代表的数字，那么栈顶就要出栈。新值接着和栈顶进行下一次的比较。直到新值大于栈顶或者栈里面没有数字了。

​	上面的步骤结束之后，记录答案，然后让新值的位置进栈，

总结一下就是： 每个值进栈的时候，都会弹掉前面那些大于等于自己的数字。

由于每个值最多进栈一次，出栈一次，所以时间复杂度是 $O(n)$ 

下面就是具体的代码：

 ```c++
stack<int>stk;
int sz = arr.size();
for (int i = 0; i < sz; ++i){
    while(stk.size() && arr[i] <= arr[stk.top()]) stk.pop(); // 如果当前的值 小于等于栈顶所代表的值， 就不断的弹栈，直到遇见大于当前的值
    L[i] = stk.size() ? stk.top() : -1;   // L 记录的是答案， 如果栈里面有值，记录的是栈顶的值，否之是 -1. 
    stk.push(i);  // 把当前位置压栈。
}
 ```

总的来说，单调栈是很好写的，我们也不需要知道这个栈是单调递增的还是单调递减的，只需要关心我们的目的就好了。是要求左边第一大于当前元素的位置还是左边第一个小于当前元素的位置。明确目的就可以直接写了。





### 训练题目：

- [ ] [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)
- [ ] [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)