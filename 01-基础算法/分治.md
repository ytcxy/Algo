## 分治

​	分治分治，分而治之。 所以分治这个算法的过程就是：分解 -> 解决 -> 合并。



**分治和递归的关系很大：**

递归是一种编程技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体问题的算法思想。

分治法能解决的问题一般有如下特征：

- 该问题的规模缩小到一定的程度就可以容易地解决。
- 该问题可以分解为若干个规模较小的相同问题。
- 该问题所分解出的各个子问题是相互独立的，即子问题之间没有关联。



这里我们拿归并排序举个例子：

#### 归并排序

归并排序的基本流程如下。

```c++
void merge_sort(一个数组){
    if (很容易处理) return;
    merge_sort(左半个数组);
    merge_sort(右半个数组);
    merge(左半个数组，右半个数组);
}
```



具体的代码如下

```java
public static void merge_sort(int[] a, int l, int r){
    if (l >= r) return; // 如果只有一个元素， 就不用排序了， 直接返回。
    int mid = (l + r) >> 1;
    merge_sort(a, l, mid);  // 递归处理左区间的数组
    merge_sort(a, mid+1, r);  // 递归处理右区间的数组

    int i = l, j = mid+1,pos = l;   // 合并两个有序的数组。 这里的 b 是一个静态数组， 开在函数的外面。
    while(i <= mid && j <= r){   // 比较左右区间的数组， 每次找一个最小的放到 b 数组中。 直到左右区间的数组有一个没有数字了。
        if (a[i] < a[j]) {
            b[pos] = a[i]; i++;
        } else {
            b[pos] = a[j]; j++;
        }
        pos++;
    }
    // 下面的两个 while 语句，只会有一个会执行。
    while(i <= mid) b[pos++] = a[i++];  // 如果 左区间数组还有数， 放到 b 数组里面。
    while(j <= r) b[pos++] = a[j++];   // 如果 右区间数组还有数， 放到b 数组里面。
    for (i = l; i <= r; ++i)   // 此时 b 数组已经有序了， 然后把数放回 a 数组。
        a[i] = b[i];
}
```



